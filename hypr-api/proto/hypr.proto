// HYPR gRPC API
// Protocol buffer definitions for HYPR daemon <-> CLI communication

syntax = "proto3";
package hypr.v1;

// ============================================================================
// Service Definition
// ============================================================================

service HyprService {
  // VM operations
  rpc CreateVM(CreateVMRequest) returns (CreateVMResponse);
  rpc StartVM(StartVMRequest) returns (StartVMResponse);
  rpc StopVM(StopVMRequest) returns (StopVMResponse);
  rpc DeleteVM(DeleteVMRequest) returns (DeleteVMResponse);
  rpc ListVms(ListVmsRequest) returns (ListVmsResponse);
  rpc GetVM(GetVMRequest) returns (GetVMResponse);

  // Combined run with streaming progress (image pull + create + start)
  rpc RunVM(RunVMRequest) returns (stream RunVMEvent);

  // Real-time VM metrics streaming (CPU, memory, network, disk I/O)
  rpc StreamVMMetrics(StreamVMMetricsRequest) returns (stream VMMetrics);

  // Logging
  rpc StreamLogs(StreamLogsRequest) returns (stream LogEntry);

  // Interactive exec with PTY support (bidirectional streaming)
  rpc Exec(stream ExecRequest) returns (stream ExecResponse);

  // Image operations
  rpc ListImages(ListImagesRequest) returns (ListImagesResponse);
  rpc GetImage(GetImageRequest) returns (GetImageResponse);
  rpc DeleteImage(DeleteImageRequest) returns (DeleteImageResponse);
  rpc GetImageHistory(GetImageHistoryRequest) returns (GetImageHistoryResponse);

  // Image pull with streaming progress (layer-by-layer)
  rpc PullImage(PullImageRequest) returns (stream PullEvent);

  // Image build with streaming progress
  rpc BuildImage(BuildImageRequest) returns (stream BuildEvent);

  // Stack operations (streaming for progress updates)
  rpc DeployStack(DeployStackRequest) returns (stream DeployStackEvent);
  rpc DestroyStack(DestroyStackRequest) returns (DestroyStackResponse);
  rpc ListStacks(ListStacksRequest) returns (ListStacksResponse);
  rpc GetStack(GetStackRequest) returns (GetStackResponse);
  rpc StreamStackServiceLogs(StreamStackServiceLogsRequest) returns (stream LogEntry);

  // Network operations
  rpc CreateNetwork(CreateNetworkRequest) returns (CreateNetworkResponse);
  rpc DeleteNetwork(DeleteNetworkRequest) returns (DeleteNetworkResponse);
  rpc ListNetworks(ListNetworksRequest) returns (ListNetworksResponse);
  rpc GetNetwork(GetNetworkRequest) returns (GetNetworkResponse);

  // Volume operations
  rpc CreateVolume(CreateVolumeRequest) returns (CreateVolumeResponse);
  rpc DeleteVolume(DeleteVolumeRequest) returns (DeleteVolumeResponse);
  rpc ListVolumes(ListVolumesRequest) returns (ListVolumesResponse);
  rpc GetVolume(GetVolumeRequest) returns (GetVolumeResponse);
  rpc PruneVolumes(PruneVolumesRequest) returns (PruneVolumesResponse);

  // System operations
  rpc GetSystemStats(GetSystemStatsRequest) returns (GetSystemStatsResponse);
  rpc Health(HealthRequest) returns (HealthResponse);

  // Settings
  rpc GetSettings(GetSettingsRequest) returns (GetSettingsResponse);
  rpc UpdateSettings(UpdateSettingsRequest) returns (UpdateSettingsResponse);

  // Real-time event subscription
  rpc SubscribeEvents(SubscribeEventsRequest) returns (stream HyprEvent);

  // Templates (P0) - Pre-configured VM templates for common workloads
  rpc ListTemplates(ListTemplatesRequest) returns (ListTemplatesResponse);
  rpc GetTemplate(GetTemplateRequest) returns (GetTemplateResponse);
  rpc CreateFromTemplate(CreateFromTemplateRequest) returns (stream RunVMEvent);

  // Snapshots (P0) - VM state snapshots for backup and restore
  rpc CreateSnapshot(CreateSnapshotRequest) returns (Snapshot);
  rpc RestoreSnapshot(RestoreSnapshotRequest) returns (VM);
  rpc ListSnapshots(ListSnapshotsRequest) returns (ListSnapshotsResponse);
  rpc GetSnapshot(GetSnapshotRequest) returns (GetSnapshotResponse);
  rpc DeleteSnapshot(DeleteSnapshotRequest) returns (DeleteSnapshotResponse);
}

// ============================================================================
// VM Types
// ============================================================================

message VM {
  string id = 1;
  string name = 2;
  string image_id = 3;
  string status = 4; // "creating", "running", "stopped", "failed", "deleting"
  VMConfig config = 5;
  optional string ip_address = 6;
  optional uint32 pid = 7;
  int64 created_at = 8; // Unix timestamp
  optional int64 started_at = 9;
  optional int64 stopped_at = 10;
}

message VMConfig {
  string id = 1;
  string name = 2;
  VMResources resources = 3;
  repeated DiskConfig disks = 4;
  NetworkConfig network = 5;
  repeated PortMapping ports = 6;
  map<string, string> env = 7;
  repeated VolumeMount volumes = 8;
  repeated string kernel_args = 9;
  optional string kernel_path = 10;
  optional GpuConfig gpu = 11;
  string vsock_path = 12;
}

message VMResources {
  uint32 cpus = 1;
  uint32 memory_mb = 2;
  bool balloon_enabled = 3; // Enable memory ballooning (default: true)
}

message DiskConfig {
  string path = 1;
  bool readonly = 2;
  string format = 3; // "squashfs", "ext4", "raw"
}

message NetworkConfig {
  string mode = 1; // "bridge", "host", "none"
  optional string cidr = 2;
  optional string gateway = 3;
}

message PortMapping {
  uint32 host_port = 1;
  uint32 guest_port = 2;
  string protocol = 3; // "tcp", "udp"
}

message VolumeMount {
  string source = 1; // Host path or volume ID
  string target = 2; // Guest mount point
  bool readonly = 3;
}

message GpuConfig {
  string vendor = 1; // "nvidia", "amd", "intel", "metal"
  optional string pci_address = 2;
  string model = 3;
  bool use_sriov = 4;
  optional uint64 gpu_memory_mb = 5;
}

// ============================================================================
// Image Types
// ============================================================================

message Image {
  string id = 1;
  string name = 2;
  string tag = 3;
  ImageManifest manifest = 4;
  string rootfs_path = 5;
  uint64 size_bytes = 6;
  int64 created_at = 7;
}

message ImageManifest {
  string version = 1;
  string name = 2;
  string tag = 3;
  string architecture = 4;
  string os = 5;
  repeated string entrypoint = 6;
  repeated string cmd = 7;
  map<string, string> env = 8;
  string workdir = 9;
  repeated uint32 exposed_ports = 10;
  RuntimeConfig runtime = 11;
  optional HealthCheckConfig health = 12;
  optional string user = 13; // User to run as (e.g., "nginx", "1000:1000")
}

message RuntimeConfig {
  uint32 default_memory_mb = 1;
  uint32 default_cpus = 2;
  string kernel_channel = 3;
  string rootfs_type = 4;
  string restart_policy = 5; // "no", "always", "on_failure", "unless_stopped"
}

message HealthCheckConfig {
  string check_type = 1; // "http", "tcp", "exec"
  optional string endpoint = 2;
  uint32 port = 3;
  uint32 interval_sec = 4;
  uint32 timeout_sec = 5;
  uint32 retries = 6;
}

// ============================================================================
// Request/Response Messages
// ============================================================================

// VM Operations

message CreateVMRequest {
  string name = 1;
  VMConfig config = 2;
  string image = 3; // Image name:tag (e.g., "nginx:latest")
}

message CreateVMResponse {
  VM vm = 1;
}

message StartVMRequest {
  string id = 1;
}

message StartVMResponse {
  VM vm = 1;
}

message StopVMRequest {
  string id = 1;
  optional uint32 timeout_sec = 2; // Default: 30
}

message StopVMResponse {
  VM vm = 1;
}

message DeleteVMRequest {
  string id = 1;
  bool force = 2; // Force delete even if running
}

message DeleteVMResponse {
  bool success = 1;
}

message ListVmsRequest {
  optional string filter = 1; // Future: filter by status, image, etc.
}

message ListVmsResponse {
  repeated VM vms = 1;
}

message GetVMRequest {
  string id = 1;
}

message GetVMResponse {
  VM vm = 1;
}

// RunVM - Combined streaming operation
message RunVMRequest {
  string image = 1;             // Image name:tag (e.g., "nginx:latest")
  optional string name = 2;     // Optional VM name
  VMConfig config = 3;          // VM configuration
}

message RunVMEvent {
  oneof event {
    RunProgress progress = 1;
    RunComplete complete = 2;
    RunError error = 3;
  }
}

message RunProgress {
  string stage = 1;             // "resolving", "pulling", "creating", "starting", "running"
  string message = 2;           // Human-readable message
  uint64 current = 3;           // Current progress (bytes for pull)
  uint64 total = 4;             // Total size (0 if unknown)
}

message RunComplete {
  VM vm = 1;
}

message RunError {
  string message = 1;
}

// Image Operations

message ListImagesRequest {
  optional string filter = 1;
}

message ListImagesResponse {
  repeated Image images = 1;
}

message GetImageRequest {
  string name = 1; // Image name (e.g., "ts-frontend")
  string tag = 2;  // Image tag (e.g., "latest")
  bool pull = 3;   // Auto-pull from registry if not found locally (default: true)
}

message GetImageResponse {
  Image image = 1;
}

message DeleteImageRequest {
  string id = 1;
  bool force = 2;
}

message DeleteImageResponse {
  bool success = 1;
}

// Stack Operations

message DeployStackRequest {
  string compose_file = 1; // Path to docker-compose.yml
  optional string stack_name = 2; // Optional stack name (defaults to directory name)
  bool detach = 3; // Run in background
  bool force_recreate = 4; // Force recreate even if exists
  bool build = 5; // Build images before deploying
}

// Streaming events for deploy progress
message DeployStackEvent {
  oneof event {
    DeployProgress progress = 1;
    DeployComplete complete = 2;
    DeployError error = 3;
  }
}

message DeployProgress {
  string service = 1;           // Service name
  string stage = 2;             // "pulling", "extracting", "starting", "running"
  string message = 3;           // Human-readable message
  uint64 current = 4;           // Current progress (bytes downloaded, etc.)
  uint64 total = 5;             // Total size (0 if unknown)
}

message DeployComplete {
  Stack stack = 1;
}

message DeployError {
  string service = 1;           // Service that failed (empty if general error)
  string message = 2;           // Error message
}

message DestroyStackRequest {
  string stack_name = 1;
  bool force = 2; // Force destroy even if running
}

message DestroyStackResponse {
  bool success = 1;
}

message ListStacksRequest {
  optional string filter = 1;
}

message ListStacksResponse {
  repeated Stack stacks = 1;
}

message GetStackRequest {
  string stack_name = 1;
}

message GetStackResponse {
  Stack stack = 1;
}

// Stack Types

message Stack {
  string id = 1;
  string name = 2;
  repeated StackService services = 3;
  optional string compose_path = 4;
  int64 created_at = 5;
}

message StackService {
  string name = 1;
  string vm_id = 2;
  string status = 3; // "creating", "running", "stopped", "failed"
}

// Health Check

message HealthRequest {}

message HealthResponse {
  string status = 1; // "healthy", "degraded", "unhealthy"
  string version = 2;
  map<string, string> details = 3;
}

// ============================================================================
// Logging Types
// ============================================================================

message StreamLogsRequest {
  string vm_id = 1;           // VM ID to stream logs from
  bool follow = 2;            // If true, continue streaming new logs (like tail -f)
  uint32 tail = 3;            // Number of lines from end to show (0 = all)
  optional int64 since = 4;   // Only show logs after this timestamp (Unix epoch)
}

message LogEntry {
  int64 timestamp = 1;        // Unix timestamp in milliseconds
  string line = 2;            // Log line content
  string stream = 3;          // "stdout" or "stderr"
}

// ============================================================================
// Network Types
// ============================================================================

message Network {
  string id = 1;
  string name = 2;
  string driver = 3;          // "bridge" (default), etc.
  string cidr = 4;            // e.g., "10.89.0.0/16"
  string gateway = 5;         // e.g., "10.89.0.1"
  string bridge_name = 6;     // e.g., "vbr1"
  int64 created_at = 7;       // Unix timestamp
}

message CreateNetworkRequest {
  string name = 1;
  optional string driver = 2;   // Default: "bridge"
  optional string subnet = 3;   // CIDR, auto-allocated if not specified
  optional string gateway = 4;  // Auto-set if not specified
}

message CreateNetworkResponse {
  Network network = 1;
}

message DeleteNetworkRequest {
  string name = 1;
  bool force = 2;             // Force delete even if VMs are attached
}

message DeleteNetworkResponse {
  bool success = 1;
}

message ListNetworksRequest {
  optional string filter = 1;
}

message ListNetworksResponse {
  repeated Network networks = 1;
}

message GetNetworkRequest {
  string name = 1;
}

message GetNetworkResponse {
  Network network = 1;
}

// ============================================================================
// VM Metrics Types (Real-time monitoring)
// ============================================================================

message StreamVMMetricsRequest {
  string vm_id = 1;
  uint32 interval_ms = 2;     // Polling interval in milliseconds (default: 1000)
}

message VMMetrics {
  int64 timestamp = 1;        // Unix timestamp in milliseconds
  double cpu_percent = 2;     // CPU usage percentage (0-100 * num_cpus)
  uint64 memory_used_bytes = 3;
  uint64 memory_total_bytes = 4;
  uint64 disk_read_bytes = 5;
  uint64 disk_write_bytes = 6;
  uint64 network_rx_bytes = 7;
  uint64 network_tx_bytes = 8;
  uint32 pids = 9;            // Number of processes in VM
}

// ============================================================================
// Exec Types (Interactive PTY)
// ============================================================================

message ExecRequest {
  oneof message {
    ExecStart start = 1;
    ExecInput input = 2;
    ExecResize resize = 3;
    ExecSignal signal = 4;
  }
}

message ExecStart {
  string vm_id = 1;
  repeated string command = 2;  // Command to execute (default: /bin/sh)
  bool tty = 3;                 // Allocate PTY
  map<string, string> env = 4;  // Environment variables
  string workdir = 5;           // Working directory
  string user = 6;              // User to run as
}

message ExecInput {
  bytes data = 1;               // Stdin data
}

message ExecResize {
  uint32 rows = 1;
  uint32 cols = 2;
}

message ExecSignal {
  int32 signal = 1;             // Signal number (e.g., 2 for SIGINT)
}

message ExecResponse {
  oneof message {
    bytes stdout = 1;
    bytes stderr = 2;
    int32 exit_code = 3;
    ExecStarted started = 4;
  }
}

message ExecStarted {
  string session_id = 1;        // Session ID for tracking
}

// ============================================================================
// Image Build Types
// ============================================================================

message BuildImageRequest {
  string context_path = 1;      // Path to build context directory
  string dockerfile = 2;        // Dockerfile path relative to context (default: Dockerfile)
  string tag = 3;               // Image tag (e.g., "myapp:latest")
  map<string, string> build_args = 4;
  optional string target = 5;   // Target build stage for multi-stage builds
  bool no_cache = 6;            // Disable build cache
  bool pull = 7;                // Always pull base images
  repeated string cache_from = 8; // Images to use as cache sources
}

message BuildEvent {
  oneof event {
    BuildStep step = 1;
    BuildOutput output = 2;
    BuildComplete complete = 3;
    BuildError error = 4;
  }
}

message BuildStep {
  uint32 step_number = 1;
  uint32 total_steps = 2;
  string instruction = 3;       // e.g., "RUN apt-get update"
  bool cached = 4;              // Whether this step used cache
}

message BuildOutput {
  string line = 1;              // Build output line
  string stream = 2;            // "stdout" or "stderr"
}

message BuildComplete {
  Image image = 1;
}

message BuildError {
  uint32 step_number = 1;
  string message = 2;
}

// ============================================================================
// Image Pull Types
// ============================================================================

message PullImageRequest {
  string image = 1;             // Image reference (e.g., "nginx:latest")
}

message PullEvent {
  oneof event {
    PullProgress progress = 1;
    PullComplete complete = 2;
    PullError error = 3;
  }
}

message PullProgress {
  string layer_id = 1;          // Layer digest (short form)
  string status = 2;            // "pulling", "downloading", "extracting", "done"
  uint64 current = 3;           // Bytes downloaded
  uint64 total = 4;             // Total bytes (0 if unknown)
}

message PullComplete {
  Image image = 1;
}

message PullError {
  string message = 1;
}

// ============================================================================
// Image History Types
// ============================================================================

message GetImageHistoryRequest {
  string image_id = 1;
}

message GetImageHistoryResponse {
  repeated ImageLayer layers = 1;
}

message ImageLayer {
  string id = 1;                // Layer ID (digest)
  string created_by = 2;        // Dockerfile instruction that created this layer
  uint64 size_bytes = 3;
  int64 created_at = 4;         // Unix timestamp
  string comment = 5;
  bool empty_layer = 6;         // True if layer adds no files
}

// ============================================================================
// Stack Service Logs
// ============================================================================

message StreamStackServiceLogsRequest {
  string stack_name = 1;
  string service_name = 2;
  bool follow = 3;
  uint32 tail = 4;
  optional int64 since = 5;
}

// ============================================================================
// Volume Types
// ============================================================================

message Volume {
  string id = 1;
  string name = 2;
  string driver = 3;            // "local" (default)
  string path = 4;              // Host path
  uint64 size_bytes = 5;
  int64 created_at = 6;
  repeated string used_by = 7;  // VM IDs using this volume
  map<string, string> labels = 8;
}

message CreateVolumeRequest {
  string name = 1;
  optional string driver = 2;   // Default: "local"
  map<string, string> labels = 3;
}

message CreateVolumeResponse {
  Volume volume = 1;
}

message DeleteVolumeRequest {
  string name = 1;
  bool force = 2;               // Force delete even if in use
}

message DeleteVolumeResponse {
  bool success = 1;
}

message ListVolumesRequest {
  optional string filter = 1;
}

message ListVolumesResponse {
  repeated Volume volumes = 1;
}

message GetVolumeRequest {
  string name = 1;
}

message GetVolumeResponse {
  Volume volume = 1;
}

message PruneVolumesRequest {
  bool all = 1;                 // Remove all unused, not just anonymous
}

message PruneVolumesResponse {
  repeated string volumes_deleted = 1;
  uint64 space_reclaimed = 2;
}

// ============================================================================
// System Stats Types
// ============================================================================

message GetSystemStatsRequest {}

message GetSystemStatsResponse {
  // VM counts
  uint32 total_vms = 1;
  uint32 running_vms = 2;
  uint32 stopped_vms = 3;

  // Resource allocation
  uint32 total_cpus_allocated = 4;
  uint64 total_memory_allocated_mb = 5;

  // Disk usage
  uint64 total_disk_used_bytes = 6;
  uint64 images_disk_used_bytes = 7;
  uint64 volumes_disk_used_bytes = 8;
  uint64 cache_disk_used_bytes = 9;
  uint64 logs_disk_used_bytes = 10;

  // Counts
  uint32 total_images = 11;
  uint32 total_stacks = 12;
  uint32 total_networks = 13;
  uint32 total_volumes = 14;
}

// ============================================================================
// Settings Types
// ============================================================================

message GetSettingsRequest {}

message GetSettingsResponse {
  Settings settings = 1;
}

message UpdateSettingsRequest {
  Settings settings = 1;
}

message UpdateSettingsResponse {
  Settings settings = 1;
}

message Settings {
  // Default VM resources
  uint32 default_cpus = 1;
  uint32 default_memory_mb = 2;

  // Daemon settings
  bool auto_start_daemon = 3;
  bool start_at_login = 4;
  string log_level = 5;         // "error", "warn", "info", "debug", "trace"

  // Resource limits
  uint32 max_concurrent_builds = 6;
  uint64 cache_size_limit_bytes = 7;
  uint64 log_retention_days = 8;

  // Telemetry
  bool telemetry_enabled = 9;

  // Paths (read-only, informational)
  string data_dir = 10;
  string runtime_dir = 11;
  string socket_path = 12;
}

// ============================================================================
// Event Subscription Types
// ============================================================================

message SubscribeEventsRequest {
  repeated string event_types = 1;  // Filter by type: "vm.*", "image.*", "stack.*", "network.*"
                                     // Empty = all events
}

message HyprEvent {
  int64 timestamp = 1;
  string type = 2;              // e.g., "vm.created", "vm.started", "image.pulled"
  string resource_type = 3;     // "vm", "image", "stack", "network", "volume"
  string resource_id = 4;
  string action = 5;            // "created", "started", "stopped", "deleted", "failed"
  string message = 6;           // Human-readable description
  map<string, string> metadata = 7;
}

// ============================================================================
// Templates Types (P0)
// ============================================================================

// Template represents a pre-configured VM template for common workloads.
message Template {
  string id = 1;                    // Unique template ID (e.g., "postgres-16")
  string name = 2;                  // Human-readable name (e.g., "PostgreSQL 16")
  string description = 3;           // Detailed description
  string category = 4;              // Category: "database", "web", "cache", "queue", "monitoring"
  string image = 5;                 // Base image (e.g., "postgres:16-alpine")
  VMResources default_resources = 6; // Default CPU/memory allocation
  repeated PortMapping default_ports = 7; // Default port mappings
  map<string, string> default_env = 8;    // Default environment variables
  repeated string tags = 9;         // Searchable tags
  string icon_url = 10;             // Optional icon URL for UI
  bool builtin = 11;                // True if this is a built-in template
}

message ListTemplatesRequest {
  optional string category = 1;     // Filter by category
  optional string search = 2;       // Search in name, description, tags
}

message ListTemplatesResponse {
  repeated Template templates = 1;
}

message GetTemplateRequest {
  string id = 1;                    // Template ID
}

message GetTemplateResponse {
  Template template = 1;
}

message CreateFromTemplateRequest {
  string template_id = 1;           // Template to create from
  optional string name = 2;         // Custom VM name (auto-generated if not provided)
  optional VMResources resources = 3; // Override default resources
  map<string, string> env = 4;      // Additional/override environment variables
  repeated PortMapping ports = 5;   // Additional/override port mappings
}

// ============================================================================
// Snapshots Types (P0)
// ============================================================================

// Snapshot represents a point-in-time capture of a VM's state.
message Snapshot {
  string id = 1;                    // Unique snapshot ID
  string vm_id = 2;                 // ID of the VM this snapshot belongs to
  string name = 3;                  // Human-readable name
  string description = 4;           // Optional description
  uint64 size_bytes = 5;            // Size of snapshot data
  int64 created_at = 6;             // Unix timestamp when created
  string state = 7;                 // "creating", "ready", "failed", "deleting"
  map<string, string> labels = 8;   // Custom labels/metadata
  SnapshotType snapshot_type = 9;   // Type of snapshot
}

// Type of snapshot captured.
enum SnapshotType {
  SNAPSHOT_TYPE_UNSPECIFIED = 0;
  SNAPSHOT_TYPE_DISK = 1;           // Disk-only snapshot (fast, VM can be running)
  SNAPSHOT_TYPE_FULL = 2;           // Full VM state including memory (VM must be paused)
}

message CreateSnapshotRequest {
  string vm_id = 1;                 // VM to snapshot
  string name = 2;                  // Snapshot name
  optional string description = 3;  // Optional description
  SnapshotType snapshot_type = 4;   // Type of snapshot (default: DISK)
  map<string, string> labels = 5;   // Custom labels
}

message RestoreSnapshotRequest {
  string snapshot_id = 1;           // Snapshot to restore from
  optional string new_vm_name = 2;  // If provided, creates a new VM; otherwise restores in-place
  bool start_after_restore = 3;     // Start the VM after restoring (default: false)
}

message ListSnapshotsRequest {
  optional string vm_id = 1;        // Filter by VM ID
  optional string name = 2;         // Filter by name (prefix match)
}

message ListSnapshotsResponse {
  repeated Snapshot snapshots = 1;
}

message GetSnapshotRequest {
  string id = 1;                    // Snapshot ID
}

message GetSnapshotResponse {
  Snapshot snapshot = 1;
}

message DeleteSnapshotRequest {
  string id = 1;                    // Snapshot ID to delete
}

message DeleteSnapshotResponse {
  bool success = 1;
}
